//generated by lazy
//author: seanlan

package service

import (
	"context"
	"encoding/json"
	"go.uber.org/zap"
	"gorm.io/gorm/clause"
	"strconv"
	"strings"
	"time"
	"token-payment/internal/dao"
	"token-payment/internal/dao/sqlmodel"
	"token-payment/internal/e"
	"token-payment/internal/handler"
	"token-payment/internal/model"
	"token-payment/internal/tokenpay"
)

func CreatePaymentAddress(ctx context.Context, req model.CreatePaymentAddressReq) (resp model.CreatePaymentAddressResp, err error) {
	var (
		data   model.CreatePaymentAddressReqData
		appQ   = sqlmodel.ApplicationColumns
		app    sqlmodel.Application
		chainQ = sqlmodel.ChainColumns
		ch     sqlmodel.Chain
		addr   sqlmodel.ChainAddress
	)
	err = dao.FetchApplication(ctx, &app, dao.And(appQ.AppKey.Eq(req.AppKey)))
	if err != nil || app.ID == 0 {
		err = e.ErrorApplicationNotFound
		return
	}
	sdk := tokenpay.NewClient(app.AppName, app.AppKey, "")
	// 检测签名
	if sdk.GetSign(req.Data) != req.Sign {
		err = e.ErrorSign
		return
	}
	// 解析data
	err = json.Unmarshal([]byte(req.Data), &data)
	if err != nil {
		zap.S().Warnf("unmarshal data error: %v", err)
		err = e.ErrorDataParam
		return
	}
	// 获取chain
	err = dao.FetchChain(ctx, &ch, dao.And(chainQ.ChainSymbol.Eq(data.Chain)))
	if err != nil || ch.ID == 0 {
		err = e.ErrorChainNotSupport
		return
	}
	addr, err = handler.GenerateAddress(ctx, &ch, app.ID, data.NotifyUrl, true)
	if err != nil {
		zap.S().Warnf("generate address error: %v", err)
		err = e.ErrServer
		return
	}
	resp.Address = addr.Address
	return
}

func Withdraw(ctx context.Context, req model.WithdrawReq) (resp model.WithdrawResp, err error) {
	var (
		data      model.WithdrawReqData
		appQ      = sqlmodel.ApplicationColumns
		app       sqlmodel.Application
		appChainQ = sqlmodel.ApplicationChainColumns
		appChain  sqlmodel.ApplicationChain
		tokenQ    = sqlmodel.ChainTokenColumns
		token     sqlmodel.ChainToken
		orderQ    = sqlmodel.ApplicationWithdrawOrderColumns
		update    int64
	)
	err = dao.FetchApplication(ctx, &app, dao.And(appQ.AppKey.Eq(req.AppKey)))
	if err != nil || app.ID == 0 {
		err = e.ErrorApplicationNotFound
		return
	}
	sdk := tokenpay.NewClient(app.AppName, app.AppKey, "")
	// 检测签名
	if sdk.GetSign(req.Data) != req.Sign {
		err = e.ErrorSign
		return
	}
	// 解析data
	err = json.Unmarshal([]byte(req.Data), &data)
	if err != nil {
		zap.S().Warnf("unmarshal data error: %v", err)
		err = e.ErrorDataParam
		return
	}
	value, err := strconv.ParseFloat(data.Value, 64)
	if err != nil {
		err = e.ErrorDataParam
		return

	}
	// 获取应用链信息
	err = dao.FetchApplicationChain(ctx, &appChain, dao.And(
		appChainQ.ApplicationID.Eq(app.ID),
		appChainQ.ChainSymbol.Eq(data.Chain),
	))
	if err != nil || appChain.ID == 0 {
		err = e.ErrorChainNotSupport
		return
	}
	// 获取token信息
	tokenParams := []clause.Expression{
		tokenQ.ChainSymbol.Eq(data.Chain),
		tokenQ.Symbol.Eq(data.Symbol),
	}
	if data.ContractAddress != "" {
		tokenParams = append(tokenParams, tokenQ.ContractAddress.Eq(data.ContractAddress))
	}
	err = dao.FetchChainToken(ctx, &token, dao.And(tokenParams...))
	if err != nil || token.ID == 0 {
		err = e.ErrorTokenNotSupport
		return
	}
	// 生成提现订单
	order := sqlmodel.ApplicationWithdrawOrder{
		ApplicationID:   app.ID,
		SerialNo:        data.SerialNo,
		ChainSymbol:     data.Chain,
		ContractAddress: token.ContractAddress,
		Symbol:          token.Symbol,
		TokenID:         data.TokenID,
		ToAddress:       strings.ToLower(data.ToAddress),
		Value:           value,
		Hook:            data.NotifyUrl,
		CreateAt:        time.Now().Unix(),
	}
	update, err = dao.UpsertApplicationWithdrawOrder(ctx, &order, dao.M{}, orderQ.SerialNo.Name, orderQ.ApplicationID.Name)
	if err != nil {
		err = e.ErrServer
		return
	}
	if update == 0 {
		resp.Exist = true
	}
	return
}
